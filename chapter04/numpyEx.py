#Numpy 특징
# Numpy는 내부적으로 데이터를 다른 내장 파이썬 객체와 구분된 연속된 메모리 블록에 저장한다. numpy의 각종 알고리즘은 모두 c로 작성되어 타입 검사나 다른 오버헤드 ㅇ벗이 메모리를 직접 조작할 수 있다.
# Numpy 배열은 또한 내장 파이썬의 연속된 자료형들보다 훨씬 더 적은 메모리를 사용한다.
# Numpy 연산은 파이썬 반복문을 사용하지 않고 전체 배열에 대한 복잡한 계산을 수행할 수 있다.

# 성능 차이를 확인하기 위해 백만 개의 정수를 저장하는 Numpy 배열과 파이썬 리스트를 비교해보자.

import numpy as np
my_arr = np.arange(1000000)
my_list = list(range(1000000))

# ipython 에서 %run 으로 이 파일을 실행시키면
# %time for _ in range(10): my_arr2 = my_arr * 2 -> Wall time: 20.6 ms
#  %time for _ in range(10): my_list2 = [x*2 for x in my_list] -> Wall time: 777 ms

# 즉 Numpy 를 사용한 코드가 순수 파이썬으로 작성한 코드보다 몇배는 훨씬 더 빠른것을 확인할 수 있다.


#---------------------------------------------------------------------------------

# Numpy ndarray : 다차원 배열 객체
# Numpy 의 핵심기능 중 하나는 ndaary라고 하는 N차원의 배열 객체인데 파이썬에서 사용할 수 있는 대규모 데이터 집합을 담을 수 있는 빠르고 유연한 자료구조이다.
# Numpy 는 같은 종류의 대이털르 담을 수 있는 포괄적인 다차원 배열이다. ndarray의 모든 원손느 같은 자료형이어야 한다.
# shape 함수 : 각 차원의 크기를 알려줌
# dtype 함수 : 튜플과 배열에 저장된 자료형을 알려줌

#ex

data = np.random.randn(2,3) # 2행 3열
print(data)

#이제 data에 산술연산을 해보자
print(data*10)
print(data+data)

print(data.shape)
print(data.dtype)

# array 함수를 이용하여 배열 생성하기

data1 = [6,7.5,8,0,1]
arr1 = np.array(data1)
print(arr1)

# 같은 길이를 가지는 리스트를 내포하고 있는 순차 데이터는 다차원 배열로 변환 가능하다.

data2 = [[1,2,3,4] , [5,6,7,8]]
arr2 = np.array(data2)
print(arr2) # 이때 np.arrapy는 생성될 때 적절한 자료형을 추론해서 결과를 보여준다.


#arange는 파이썬의 range함수의 배열 버전이다.
print(np.arange(15))

# -------------------------------------------------------------------------------

# ndarray 의 dtype
# dtype 는 ndarray 가 메모리에 있는 특정 데이터를 해석하기 위해 필요한 정보(또는 메타 데이터)를 담고 있는 특수한 객체이다.
# numpy 의 모든 dtype 를 외울 필요는 없다. 주로 사용하게 될 자료형은 부동소수점/복소수/정수/불리언/문자욜/일반 파이썬 정도이다.

# ndarray의 astype메서드를 사용해서 배열의 dtype를 다른형으로 묵시적으로 변환(캐스팅)이 가능하다.

# -------------------------------------------------------------------------------

# Numpy 배열의 산술 연산
# 배열의 중요한 특징은 for문을 작성하지 않고 데이터를 일괄 처리할 수 있다는 것이다.(백터화)

# ex

arr = np.array([[1.,2.,3.],[4.,5.,6.]])
print(arr)
print(arr*arr)
print(arr-arr)
print(arr*0.5)

# 같은 크기를 가지는 배열간의 비교 연산은 불리언 배열을 반환한다.

arr2 = np.array([[0.4,4.,1.],[7.0,2.0,12.]])

print(arr2 > arr)


# -------------------------------------------------------------------------------

# 색인과 슬라이싱 기초

arr = np.arange(10)
print(arr)
print(arr[5])
print(arr[5:8])
arr[5:8] = 12
print(arr)

arr_slice = arr[5:8]
print(arr_slice)
arr_slice = 12345
print(arr)

# 2차원 배열에서 각 색인에 해당하는 요소는 스칼라값이 아니라 1차원 배열이다.

arr2d = np.array([[1,2,3],[4,5,6],[7,8,9]])
arr2d[2]
print(arr2d)

# 2차원 배열에서 개별 요소를 재귀적으로 접근하기
print(arr2d[0][2])
print(arr2d[0,2])

#다차원 배열

arr3d = np.array([[1,2,3],[4,5,6],[7,8,9],[10,11,12]])
print(arr3d)

print(arr3d[0])

# 146Page  i dont know....


# -------------------------------------------------------------------------------

# 불리언값으로 선택하기

names = np.array(['BOb','Joe','Will','Bob','Will','Joe','Joe'])
data =np.random.randn(7,4)
print(names)
print(data)

print(names == 'Bob')
# 150Page ~ 152page i dont know....

# -------------------------------------------------------------------------------

# 펜시 색인
# 펜시 색인은 정수 배열을 사용한 색인을 설명하기 위해 Numpy에서 차용한 단어이다.

arr = np.empty((8,4))

for i in range(8):
    arr[i] = i

print(arr)

# 특정한 순서로 로우를 선택하고 싶은 경우는 원하는 순서가 명시된 정수가 담긴 ndarray나 리스트를 넘기면 된다.

print(arr[[4,3,0,6]])

# 색인으로 음수를 사용하면 끝에서부터 로우를 선택하게 된다. ????????
print(arr[[-3,-5,-7]])
print('---------------------------')
arr = np.arange(32).reshape((8,4))
print(arr)

print(arr[[1,5,7,2],[0,3,1,2]]) #펜시의 결과는 배열이 몇 차원이던지 항상 1차원으로 나타나게 된다.

# -------------------------------------------------------------------------------

