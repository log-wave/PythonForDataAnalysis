#Numpy 특징
# Numpy는 내부적으로 데이터를 다른 내장 파이썬 객체와 구분된 연속된 메모리 블록에 저장한다. numpy의 각종 알고리즘은 모두 c로 작성되어 타입 검사나 다른 오버헤드 ㅇ벗이 메모리를 직접 조작할 수 있다.
# Numpy 배열은 또한 내장 파이썬의 연속된 자료형들보다 훨씬 더 적은 메모리를 사용한다.
# Numpy 연산은 파이썬 반복문을 사용하지 않고 전체 배열에 대한 복잡한 계산을 수행할 수 있다.

# 성능 차이를 확인하기 위해 백만 개의 정수를 저장하는 Numpy 배열과 파이썬 리스트를 비교해보자.
import matplotlib.pyplot as plt
import numpy as np
my_arr = np.arange(1000000)
my_list = list(range(1000000))

# ipython 에서 %run 으로 이 파일을 실행시키면
# %time for _ in range(10): my_arr2 = my_arr * 2 -> Wall time: 20.6 ms
#  %time for _ in range(10): my_list2 = [x*2 for x in my_list] -> Wall time: 777 ms

# 즉 Numpy 를 사용한 코드가 순수 파이썬으로 작성한 코드보다 몇배는 훨씬 더 빠른것을 확인할 수 있다.


#---------------------------------------------------------------------------------

# Numpy ndarray : 다차원 배열 객체
# Numpy 의 핵심기능 중 하나는 ndaary라고 하는 N차원의 배열 객체인데 파이썬에서 사용할 수 있는 대규모 데이터 집합을 담을 수 있는 빠르고 유연한 자료구조이다.
# Numpy 는 같은 종류의 대이털르 담을 수 있는 포괄적인 다차원 배열이다. ndarray의 모든 원손느 같은 자료형이어야 한다.
# shape 함수 : 각 차원의 크기를 알려줌
# dtype 함수 : 튜플과 배열에 저장된 자료형을 알려줌

#ex

data = np.random.randn(2,3) # 2행 3열
print(data)

#이제 data에 산술연산을 해보자
print(data*10)
print(data+data)

print(data.shape)
print(data.dtype)

# array 함수를 이용하여 배열 생성하기

data1 = [6,7.5,8,0,1]
arr1 = np.array(data1)
print(arr1)

# 같은 길이를 가지는 리스트를 내포하고 있는 순차 데이터는 다차원 배열로 변환 가능하다.

data2 = [[1,2,3,4] , [5,6,7,8]]
arr2 = np.array(data2)
print(arr2) # 이때 np.arrapy는 생성될 때 적절한 자료형을 추론해서 결과를 보여준다.


#arange는 파이썬의 range함수의 배열 버전이다.
print(np.arange(15))

# -------------------------------------------------------------------------------

# ndarray 의 dtype
# dtype 는 ndarray 가 메모리에 있는 특정 데이터를 해석하기 위해 필요한 정보(또는 메타 데이터)를 담고 있는 특수한 객체이다.
# numpy 의 모든 dtype 를 외울 필요는 없다. 주로 사용하게 될 자료형은 부동소수점/복소수/정수/불리언/문자욜/일반 파이썬 정도이다.

# ndarray의 astype메서드를 사용해서 배열의 dtype를 다른형으로 묵시적으로 변환(캐스팅)이 가능하다.

# -------------------------------------------------------------------------------

# Numpy 배열의 산술 연산
# 배열의 중요한 특징은 for문을 작성하지 않고 데이터를 일괄 처리할 수 있다는 것이다.(백터화)

# ex

arr = np.array([[1.,2.,3.],[4.,5.,6.]])
print(arr)
print(arr*arr)
print(arr-arr)
print(arr*0.5)

# 같은 크기를 가지는 배열간의 비교 연산은 불리언 배열을 반환한다.

arr2 = np.array([[0.4,4.,1.],[7.0,2.0,12.]])

print(arr2 > arr)


# -------------------------------------------------------------------------------

# 색인과 슬라이싱 기초

arr = np.arange(10)
print(arr)
print(arr[5])
print(arr[5:8])
arr[5:8] = 12
print(arr)

arr_slice = arr[5:8]
print(arr_slice)
arr_slice = 12345
print(arr)

# 2차원 배열에서 각 색인에 해당하는 요소는 스칼라값이 아니라 1차원 배열이다.

arr2d = np.array([[1,2,3],[4,5,6],[7,8,9]])
arr2d[2]
print(arr2d)

# 2차원 배열에서 개별 요소를 재귀적으로 접근하기
print(arr2d[0][2])
print(arr2d[0,2])

#다차원 배열

arr3d = np.array([[1,2,3],[4,5,6],[7,8,9],[10,11,12]])
print(arr3d)

print(arr3d[0])

# 146Page  i dont know....


# -------------------------------------------------------------------------------

# 불리언값으로 선택하기

names = np.array(['BOb','Joe','Will','Bob','Will','Joe','Joe'])
data =np.random.randn(7,4)
print(names)
print(data)

print(names == 'Bob')
# 150Page ~ 152page i dont know....

# -------------------------------------------------------------------------------

# 펜시 색인
# 펜시 색인은 정수 배열을 사용한 색인을 설명하기 위해 Numpy에서 차용한 단어이다.

arr = np.empty((8,4))

for i in range(8):
    arr[i] = i

print(arr)

# 특정한 순서로 로우를 선택하고 싶은 경우는 원하는 순서가 명시된 정수가 담긴 ndarray나 리스트를 넘기면 된다.

print(arr[[4,3,0,6]])

# 색인으로 음수를 사용하면 끝에서부터 로우를 선택하게 된다. ????????
print(arr[[-3,-5,-7]])
print('---------------------------')
arr = np.arange(32).reshape((8,4))
print(arr)

print(arr[[1,5,7,2],[0,3,1,2]]) #펜시의 결과는 배열이 몇 차원이던지 항상 1차원으로 나타나게 된다.

# -------------------------------------------------------------------------------


# 배열 전치와 축 바꾸기
# 배열 전치는 데이터를 복사하지 않고 데이터의 모양이 바뀐 뷰를 반환하는 특별한 기능이다.

arr = np.arange(15).reshape((3,5))
print(arr)
print(arr.T)

# -------------------------------------------------------------------------------

# 유니버설 함수 : 배열의 각 원소를 빠르게 처리하는 함수
# unfc라고 불리기도 하는 유니버설 함수는 ndaary 안에 있는 데이터 원소별로 연산을 수행하는 함수이다. 유니버설 함수는 하나 이상으 ㅣ스칼라값을 받아서 하나 이상의 스칼라 결과과값을 반환하는
# 간단한 함수를 고속으로 수행할 수 있는 백터화된 래퍼 함수이다.

# 단항 유니버설 함수
arr = np.arange(10)
print(arr)
print(np.sqrt(arr)) #sqrt() 함수 : 해당 숫자의 제곱근을 반환
print(np.exp(arr))  #exp() 함수  : 밑이 자연상수인 지수함수로 변환

# 이항 유니버설 함수
x = np.random.randn(8)
y = np.random.randn(8)
print(x)
print(y)

print(np.maximum(x,y)) #numpy.maximum 은 x 와 y의 원소별로 가장 큰값을 계산한다.


# -------------------------------------------------------------------------------

# 배열을 이용한 배열지향 프로그래밍

# Numpy 배열을 이용하면 반복문을 사용하지 않고 간결한 배열연산이 가능하다.
# 배열 연산을 사용해서 반복문을 명시적으로 제거하는 기법을 백터화 라고 한다.

# np.meshgrid 함수는 두개의 1차원 배열을 받아서 가능한 모든 (x,y)짝을 만들 수 있는 2차원 배열 두개를 반환한다.

points = np.arange(-5,5,0.01) # -5 ~ 4.99 까지 0.01씩 증가하는 값들의 배열

xs,ys = np.meshgrid(points,points)

print(ys)

print('----------------')
z=np.sqrt(xs**2 + ys**2)
print(z)

# -------------------------------------------------------------------------------

# 배열 연산으로 조건절 표현하기
# numpy.where 함수는 x if 조건 else y 같은 삼항시의 백터화된 버전이다.

# ex

xarr = np.array([1.1,1.2,1.3,1.4,1.5])
yarr = np.array([2.1,2.2,2.3,2.4,2.5])
cond = np.array([True,False,True,True,False])

# cond의 값이 True 일때는 xarr의 값을 취하고 아니면 yarr의 값을 취하고 싶다면 리스트 표기법을 이용해서 다음처럼 작성할 수 있다.
result = [(x if c else y)
          for x,y,c in zip(xarr,yarr,cond)]
print(result)

# 이 방법에는 몇가지 문제가 있는데 , 순수 파이썬으로 수행되기 때문에 큰 배열을 빠르게 처리하지 못한다.
# 또한 다차원배열에서는 사용할 수가 없다.  -> np.where 를 사용해서 아주 간결하게 작성할 수 있다.

result = np.where(cond,xarr,yarr)
print(result)

# np.where 를 이용하여 임의의 스칼라 배열을 생성한뒤 양수면 7 , 음수면 -1 로 바꾸어보자

arr = np.random.randn(4,4)
print(arr > 0)
print('--------')
print(np.where(arr>0,7,-1))

# np.where를 사용할때 스칼라값과 배열을 조합할 수 있다.
np.where(arr>0 ,2,arr) #양수인 경우에만 2를 대입한다
print(np.where(arr>0 ,2,arr))
print('--------')
# -------------------------------------------------------------------------------

# 수학 메서드와 통계 메서드

# 배열 전체 혹은 배열에서 한 축을 따르는 자료에 대한 통꼐를 계싼하는 수학 함수는 배열 메서드로 사용할 수 있다.
# 전체의 합(sum) / 평균 (mean) / 표준편차(std) 는  Numpy의 최상위함수를 이용하거나 배열의 인스턴스 메서드를 사용해서 구할 수 있다.

# 임의의 정규 분포 데이터를 생성하고 집계해보자 .

arr = np.random.randn(5,4)
print(arr.mean())
print(arr.sum())

# arr.sum(0) : 로우의 합
# arr.mean(1) : 모든 컬럼에서 평균

# -------------------------------------------------------------------------------

# 불리언 배열을 위한 메서드

# 이전 메서드의 불리언값을 1(true) 또는 0(false)로 강제할 수 있다. 따라서 sum메서드를 실행하면 불리언 배열에서 true인 원소의 개수를 셀 수 있다.

arr = np.random.randn(100)
print((arr>0).sum())

# any 메서드는 하나 이상의 값이 true인지를 검사하고 / all 메서드는 모든 원소가 true인지를 검사한다.
bools = np.array([False,False,True,False])
print(bools.any())
print(bools.all())

# -------------------------------------------------------------------------------

# 정렬
# numpy 배열 역시 sort 메서드를 이용해서 정렬 할 수 있다.
arr = np.random.randn(6)
print(arr.sort())

# 다차원 배열의 정렬은 sort ㅔ서드에 넘긴 축의 갑에 따라 1차원 부분을 정렬한다.
arr = np.random.randn(5,3)
print(arr)
arr.sort(1)

# np.sort 매서드는 배열을 직접 변경하지 않고 정렬된 결과를 가지고 있는 복사본을 반환한다.
# 배열의 분위위수를 구하는 쉽고 빠른 방법은 우선 배열을 정렬한 후 특정분위의 값을 선택하는 것이다.

large_arr= np.random.randn(1000)
large_arr.sort()
large_arr[int(0.05 * len(large_arr)) ]# 5%분위수


# 집합 관련 함수

# numpy는 1차원 ndarry를 위한 몇가지 기본적인 집합 연산을 제공한다.
# 가장 자주 사용하는 배열 내에서 중복된 원소를 제거하고 남은 원소를 정렬된 형태로 반환해보자

names = np.array(['Bob','Joe','WIll','Joe','Joe','Mian'])
print(np.unique(names))

#np.in1d 함수는 두개의 배열을 인자로 받아서 첫 번째 배열의 원소가 두 번째 배열의 원소를 포함하는 나타내는 불리언 배열을 반환한다.

values = np.array([6,0,0,3,2,5,6])
print(np.in1d(values,[2,3,6]))

# -------------------------------------------------------------------------------

# 선형 대수
# 행렬의 곱셉, 분할 , 행렬식 그리고 정사각 행렬 수학같은 선형 대수는 배열을 다루는 라이브러리에서 즁요한 부분이다.
# 매트랩 같은 언어와 다르게 두개의 2차원 배열을 * 연산자로 곱하면 행렬 곱셈이 아니라 대응하는 각각의 원소의 곱을 계산한다.
x = np.array([[1,2,3],[4,5,6]])
y = np.array([[6,23],[-1,7],[8,9]])
print(x)
print(y)
print(x.dot(y))

# x.dot(y) = np.dot(x,y)

# 2차원 배열과 곱셈이 가능한 크기의 1차원 배열간의 행렬 곱셈의 결과는 1차원 배열이다.

#p172~ p73 idk...

# -------------------------------------------------------------------------------


# 난수 생성

# numpy.random 모듈은 파이썬 내장 랜덤 함수를 보강하여 다양한 종류의 확률분포로부터 효고하적으로 표본값을 생성하는데 주로 사용된다.
# 예를들어 normal 를 사용하여 표준정규분포로 부터 4 x 4 크기의 표본을 생성할 수 있다.

samples = np.random.normal(size=(4,4))
print(samples)

# -------------------------------------------------------------------------------

# 계단 오르내리기 예제

# 계단 중간에서 같은 확률로 한 계단 올라가거나 내려간다고 가정한다.

# 우선 순수 파이썬으로 내장 random 모듈울 사용해서 계단 오르내리기를 1000번 수행하자

import random

position = 0
walk = [position]
steps = 1000
for i in range(steps):
    step = 1 if random.randint(0,1) else -1
    position += step
    walk.append(position)

print(plt.plot(walk[:100]))

# p176~ p180 idk..................

# -------------------------------------------------------------------------------